의존성 주입을 더욱 신경썼다!!!
하나의 컨텍스트 기준 ----
1. 라우터 이동시 날짜 기억하도록!
2. not a number  나오던 것 
3. 코드 리팩토링 
```jsx
const getAdList = useCallback(async () => {  
    listDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: true });  
    _try_ {  
      const response = _await_ adService?.getAdList();  
      listDispatch({  
        type: DataActionEnum.SET_DATA,  
        data: response?.ads || [],  
      });  
    } _catch_ (e) {  
      console.error(e);  
    } _finally_ {  
      listDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: false });  
    }  
  }, [adService, listDispatch]);  const getAdTrend = useCallback(async () => {  
    trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: true });  
    _try_ {  
      const response = _await_ adService?.getTrend();  
      trendDispatch({  
        type: DataActionEnum.SET_DATA,  
        data: response?.report.daily || [],  
      });  
    } _catch_ (e) {  
      console.error(e);  
    } _finally_ {  
      trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading: false });  
    }  
  }, [adService, trendDispatch]);
```
-> 리팩토링 중복되는 리스폰스를 react-query 사용하여 
```Jsx
const { isLoading, data: trendData } = useQuery(  
    ['trend'],  
    () => adService?.getTrend(),  
    {  
      staleTime: 1000 * 60 * 60,  
      cacheTime: 1000 * 60 * 60,  
    }  
  );  const { data: listData } = useQuery(  
    ['adList'],  
    () => adService?.getAdList(),  
    {  
      staleTime: 1000 * 60 * 60,  
      cacheTime: 1000 * 60 * 60,  
    }  
  );

[1:48](https://8-otj4940.slack.com/archives/C048T2ABZFS/p1667753304664119)

useEffect(() => {  
    trendDispatch({  
      type: DataActionEnum.SET_DATA,  
      data: trendData?.report.daily || [],  
    });  
    trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading });  
  }, [trendData, isLoading]);  useEffect(() => {  
    listDispatch({  
      type: DataActionEnum.SET_DATA,  
      data: listData?.ads || [],  
    });  
  }, [listData]);
```

