록
# 1. Git

Git은 분산형 버전 관리 시스템 (DVC: Distributed Version Control)이다.

이전의 CVS(Centralized Version Control)는 오프라인으로 작업이 어려운 점, 서버가 죽으면 데이터가 다 날라가 버리는 단점 등을 있었다.

Git은 오프라인에서도 작업을 할 수 있으며, 개발자 모두가 같은 history를 가지고 있기 때문에 서버가 죽어도 쉽게 복구 시킬 수 있는 장점을 가지고 있다.

![[scenario_without_using_Git.png]]

이렇게 많은 사람이 함께 사용할 수 있는 Git을 잘 사용하기 위해서는 서로 간의 약속이 필요하고 

이걸 **Commit Message Convention**이라고 부른다. 

이러한 convention을 지킴으로써 작성자가 아닌 다른 사람이 코드를 읽을 때 어떤 목적으로 코드를 구성했는지 쉽게 알 수 있는 장점이 있다. 또한 commit message를 잘 작성해야 문서적 가치를 만들 수 있습니다.

## 1.1 Git history 

git history는 프로젝트가 어떤 문제들을 해결해왔는지 남기는 **발자취**와 같다고 생각된다. 그렇기 때문에 history에 불필요한 commit들이 남발 되어 있다면 프로젝트가 해결하고자 한 문제점들을 한눈에 알아보기 힘들다. 이러한 부분을 막기 위해서 “**squash merge**”와 “**rebase merge**” 전략이 존재한다.

### merge

하나의 문제를 해결하기 위해서 브랜치를 만들고 그 브랜치에서 작업을 한 후에 커밋들을 그냥 merge를 하게 되면 브랜치를 파기 전 commit과 이어져 history에 남게 되고 복잡해진다.

![[스크린샷 2022-12-07 오후 3.00.07.png]]

### Squash merge

![[스크린샷 2022-12-07 오후 3.00.25.png]]

이것을 해결하기 위해서 사용할 수 있는 방법이 squash merge라는 방법으로 branch의 여러 개의 커밋을 하나의 커밋으로 합쳐서 기존 브랜치에 merge할 수 있다. 하나의 main branch만 남게 됨으로 history가 더 간결해지는 장점을 가진다. 
하지만 a,b,c 서로 다른 내용이 하나로 합쳐지기 때문에 자세한 내용은 볼 수 없다는 단점도 가진다.

### Rebase merge
![[스크린샷 2022-12-07 오후 3.01.21.png]]

하나하나의 내용을 담을 수 있는 방법으로는 rebase merge로 기존 branch를 만든 init 커밋에서 부모를 e로 rebase를 해 합치는 방식이다. squash merge와 달리 각각의 커밋을 볼 수 있지만 여전히 세부적인 커밋들이 많아질 수도 있다는 단점이 존재한다.

# 2. ESLint 와 Prettier

![[스크린샷 2022-12-07 오후 3.02.46.png]]

## ESLint

ESLint는 자바스크립트에서 에러가 날 수 있는 버그들을 잡아 줄 수 있는 툴이다.
코드와 관련된 두 가지 일을 하는데 하나는 **code formatting,** 다른 하나는 **code quality**이다. 두 가지 일을 다 할 수 있지만 ESLint는 주로 후자인 code quality에 대한 역할을 주로 담당하고, code formatting은 prettier에 일임하는 형식으로 둘을 함께 사용한다.

Code quality부분은 자바스크립트 내부에서 버그가 발생할 수 있거나 불필요한 코드 등에 대해 경고를 미리 던져 주는 역할을 한다. 코드 내에 `console.log()`가 남아있을 때 에러를 던져 주거나, ` ;`로 끝나지 않았을 때 수정 해주는 등의 일을 할 수 있다. 설정 파일은 .eslintrc.js로 원하는 확장자나 규칙들을 추가해서 사용할 수 있고,` eslint `을 이용하면 직접 실행할 수 있고 `eslint --fix`를 사용하면 ESLint에서 수정할 수 있는 에러를 수정해준다.

## Prettier

Prettier는 **code formatting**을 위한 툴이다. 

prettier와 ESLint의 충돌을 막기 위해서는 간단하게 plugin을 추가하면 되는데, 우선 “eslint-config-prettier”와 “eslint-plugin-prettier” 두 가지 패키지를 설치한다. 설치 후에는 간단하게 .eslintrc.js파일에 해당 플러그인을 추가하면 된다.

앞서 얘기한 대로 vscode에는 extension이 이미 존재하기 때문에 extension을 사용할 수 있지만, 새로 vscode를 설치하거나 다른 에디터를 사용하는 경우 등 플러그인만 사용하면 자동화가 어려울 수 있다. 일일이 eslint를 돌려보고 버전 관리를 할 수는 없기 때문에 프로젝트를 받고 자동으로 실행해 줄 수 있는 자동화가 필요하다.

## Git hook과 husky를 이용한 자동화

위의 문제를 해결하는 방법으로 **Git hook과 husky**를 함께 사용할 수 있다.
Git hook은 git 명령어 사용 전 후에 특정 동작을 실행할 수 있게 설정하는 방법이다. git hook만으로는 설정이 복잡하기 때문에 husky를 이용해서 미리 세팅해둔 git hook을 적용시킬 수 있다.

husky는 `npx husky add .husky/pre-commit "npm run lint"` 와 같이 간단하게 해당 git hook에 맞는 명령어를 저장할 수 있다. 실행하면 .husky라는 폴더가 생기고 해당 hook을 자동으로 실행 해주는 파일이 생성된다. 이것을 이용하면 package.json에 있는 lint라는 script를 커밋 전에 ESLint로 확인한 후에, 통과하면 커밋을 할 수 있게 자동화가 가능하다.

git hook과 husky를 이용해서 세팅하는 전반적인 과정은 다음과 같이 정리할 수 있다.

1.  처음 husky를 설치 `npm i husky --save-dev`
2. `npx husky install` : husky에 등록된 hook을 실제 .git에 적용시키기 위한 스크립
3. 이후에 clone 받아서 사용하는 사람들은 npm install후에 자동으로 husky install 이 될 수 있도록 하는 설정
```js
{  
	"scripts": { 
				"postinstall": "husky install", 	
				}, 
}
```
    
4.  scripts에 자동화할 ESLint와 Prettier 명령어 추가하기
    
```js
{  
	"scripts": { 
				"postinstall": "husky install", 	
				"format": "prettier --cache --write .", 	
				"lint": "eslint --cache .",   
				}, 
}
```


5. 필요한 hook 추가하기
	- npx husky add .husky/pre-push "npm run lint"
	- npx husky add .husky/pre-commit "npm run format"


[[팀의 능률을 올리는 방법]]




