### : Comments

-   어떤 상태로 다른 페이지에 이동했다 하더라도, 다시 기존 페이지로 복귀 할 시 마지막 상태가 유지되어야 함 (필터링 상태 등)
    -   전역 상태는 ==redux, recoil 뿐==일까? ==queryString???? url의 쿼리스트링 붙히면서 전여긍로 상태를 관리할 수 있다.== 
	==결정적으로 어떤 차이?== 전역 상태관리를 **queryString**를 먼저 사용해보는게 더 중요할 수 있다. 
	why? 전역 상태하면 리덕스로 달려가는데 전역이 아닌 것들도 리덕스로 관리하는 경우도 있다. 
	그리고 어떤 기준으로 전역상태 ?? 

-   서버로부터 받아오는 데이터를 어떻게 하면 깔끔하게 처리할 수 있을까?
    -   ==단순 계산 로직, 도메인 관련 로직(비지니스 규칙), 뷰==를 기준으로 대략적으로만 함수를 분리하기만 해도 상당히 깔끔해짐.
	(서로 비슷한 관심사를 가지고 있는 애들이 모여있는지? 를 생각해야한다. )
-   과제를 살펴보면서 커리큘럼을 조정해야 할 수도 있겠다 싶은 생각이 들었음 (Redux 보다 다른 부분에 시간을 더 많이 쓰는게 도움이 될 수도 있을 것 같음)
    -   예상 1) Redux → React Query (+ Redux)
    -   예상 2) React Query → CSR / SSR

1번 리팩토링 
변수명을 정확히 적자 
그리고 context API를 사용해서 전역에서 관리해도될 것 같다. 
![[스크린샷 2022-11-08 오후 8.38.57.png]]
0 , 1의 의미가 불분명하다 

```tsx
const AdStatusList = (daily: Props) => {
	const { startDate, endDate } = getLocalStorage('FilterDate');
	const { requestTrendData, trendData } = useTrendData();
	const [kpiValue, setKpiValue] = useState<KPIRemoveDate[]>();

	useEffect(() => {
		requestTrendData();
		return;
	}, []);

	useEffect(() => {
		if (trendData.length !== 0) {
			const res = getKPI(trendData, dateToString(new Date(startDate)), dateToString(new Date(endDate)));
			setKpiValue(res);
		}
	}, [daily]);

	return (
		<>
			{trendData.length !== 0 && kpiValue ? (
				<AdStatusListWrap>
					<Roas sum={kpiValue[0].roas} exSum={kpiValue[1].roas} />
					<Cost sum={kpiValue[0].cost} exSum={kpiValue[1].cost} />
					<Imp sum={kpiValue[0].imp} exSum={kpiValue[1].imp} />
					<Click sum={kpiValue[0].click} exSum={kpiValue[1].click} />
					<Conv sum={kpiValue[0].conv} exSum={kpiValue[1].conv} />
					<Revenue sum={(kpiValue[0].roas * kpiValue[0].cost) / 100} exSum={(kpiValue[1].roas * kpiValue[1].cost) / 100} />
				</AdStatusListWrap>
			) : (
				<AdStatusListWrap>
					<Roas sum={0} exSum={0} />
					<Cost sum={0} exSum={0} />
					<Imp sum={0} exSum={0} />
					<Click sum={0} exSum={0} />
					<Conv sum={0} exSum={0} />
					<Revenue sum={0} exSum={0} />
				</AdStatusListWrap>
			)}
		</>
	);
};

```

-   sum, exSum, Imp(**impressions**)
-   useTrendData vs KpiValue
-   import useTrendData from '@src/hooks/useTrendData';

2번 
```jsx
export class AdStatusService {
  get() {
    return axios({
      method: 'get',
      url: '/data/trend-data.json',
    });
  }
}
```

```tsx
const useAdStatus = () => {
  const [adStatusList, setAdStatusList] = useRecoilState(adStatusListAtom);

  const getAdStatus = useCallback(async () => {
    const adStatusService = new AdStatusService();

    const result = await adStatusService.get();
    setAdStatusList(result.data.report.daily);
  }, [setAdStatusList]);

  useEffect(() => {
    getAdStatus();
  }, [getAdStatus]);

  return { adStatusList, setAdStatusList };
};


const useAdStatus = () => {
  const [adStatusList, setAdStatusList] = useRecoilState(adStatusListAtom);

  

  useEffect(() => {
	const getAdStatus = (async () => {
    const adStatusService = new AdStatusService();
    const result = await adStatusService.get();
    setAdStatusList(result.data.report.daily);
  };
  getAdStatus();
  }, []);

  return { adStatusList, setAdStatusList };
};
```
의존성은 없을 수록 굿
    
suggestion
```jsx
const useAdStatus = () => {
  const [adStatusList, setAdStatusList] = useRecoilState(adStatusListAtom);

  const getAdStatus = useCallback(async () => {
    const adStatusService = new AdStatusService();

    const result = await adStatusService.get();
    setAdStatusList(result.data.report.daily);
  }, [setAdStatusList]);

  useEffect(() => {
    getAdStatus();
  }, [getAdStatus]);

  return { adStatusList, setAdStatusList };
};

    
```tsx
    class AdService {
      async getPerformances() {
        const res = await axios({
          method: 'get',
          url: '/data/trend-data.json',
        });
    
        return res.data.report.daily;
      }
    }
    
    export default new AdService()
```
    
 ```tsx
    const useAdPerformances = () => {
      const [adPerformances, setAdPerformances] = useRecoilState(adPerformancesAtom);
    
      useEffect(() => {
        const getAdPerformances = async () => {
          const performances = await AdService.getPerformances()
    
          setAdPerformances(performances);
        };
    
        getAdPerformances();
      }, []);
    
      return { adPerformances, setAdPerformances };
    };
```

```tsx
const adManagementCardListSelector = selector({
  key: 'adManagementCardListSelector',
  get: ({ get }) => {
    const adManagingList = get(adManagingListAtom);
    return adManagingList.map(listItem => {
      const statusKoName = listItem.status === 'active' ? '진행중' : '중단';
      const adTypeToKo = listItem.adType === 'web' ? '웹광고' : '앱광고';

      return {
        id: listItem.id,
        title: listItem.title,
        adType: adTypeToKo,
        report: [
          {
            key: 'status',
            name: '상태',
            value: statusKoName,
            engValue: listItem.status,
          },
          {
            key: 'startDate',
            name: '광고 생성일',
            value: format(new Date(listItem.startDate), 'yyyy-MM-dd'),
          },
          {
            key: 'budget',
            name: '일 희망 예산',
            value: getValueWithKoreanUnit('budget', listItem.budget),
          },
          {
            key: 'roas',
            name: '광고 수익률',
            value: `${getValueWithKoreanUnit('roas', listItem.report.roas)}%`,
          },
          {
            key: 'convValue',
            name: '매출',
            value: getValueWithKoreanUnit(
              'convValue',
              listItem.report.convValue
            ),
          },
          {
            key: 'cost',
            name: '광고 비용',
            value: getValueWithKoreanUnit('cost', listItem.report.cost),
          },
        ],
      };
    });
  },
});
```

-   adManagementCardListSelector 의 역할은 무엇일까? ⇒ 무엇을 return 해야 할까?

```tsx
export default function DashboardPage() {
  const [isToggle, setIsToggle] = useState(false);
  const setIsLoading = useSetRecoilState(isLoading);
  const filters = useRecoilValue(filterState);
  const [selectedDay, setSelectedDay] = useState({
    from: filters.date?.from,
    to: filters.date?.to
  });
  const handleToggle = () => {
    setIsToggle((prev) => !prev);
  };

  useEffect(() => {
    setSelectedDay({ from: filters.date?.from, to: filters.date?.to });
    setIsLoading(false);
  }, [filters]);

  return (
    <StyledDashboard>
      <StyledTitle>
        <Typography size='xxlg' variant='default'>
          대시보드
        </Typography>
        <StyledDatePicker>
          <DaypickerContainer onClick={handleToggle}>
            {`${
              selectedDay.from === undefined
                ? '기준일'
                : convertDateToKo(selectedDay.from)
            } ~ ${
              selectedDay.to === undefined
                ? '선택일'
                : convertDateToKo(selectedDay.to)
            }`}
            -> {`${from} ~ ${to}`}
            <Icons.ArrowDown />
          </DaypickerContainer>
          {isToggle && <DashboardDataPicker setIsToggle={setIsToggle} />}
        </StyledDatePicker>
      </StyledTitle>
      <AdStatusContainer />
    </StyledDashboard>
  );
}
```
![[스크린샷 2022-11-08 오후 9.02.33.png]]

-   정리 후 유의미한 로직만 노출하자
    
-   suggestion
	==파생== 이란 state로부터 계산된 값.
	
    
    ```tsx
    export default function DashboardPage() {
      const { selectedDay } = useSelectedDay();
      const { isDatePickerOpen, toggleDatePicker } = useToggleDatePicker();
    
      const { from, to } = selectedDay;
      const formatFrom = convertDateToKo(from, { defaultText: '기준일' });
      const formatTo = convertDateToKo(to, { defaultText: '선택일' });
    
      return (
        <StyledDashboard>
          <StyledTitle>
            <Typography size='xxlg' variant='default'>
              대시보드
            </Typography>
            <StyledDatePicker>
              <DaypickerContainer onClick={toggleDatePicker}>
                {`${formatFrom} ~ ${formatTo}`}
                <Icons.ArrowDown />
              </DaypickerContainer>
              {isDatePickerOpen && (
                <DashboardDataPicker setIsToggle={toggleDatePicker} />
              )}
            </StyledDatePicker>
          </StyledTitle>
          <AdStatusContainer />
        </StyledDashboard>
      );
    }
    
    const useSelectedDay = () => {
      const filters = useRecoilValue(filterState);
      const [selectedDay, setSelectedDay] = useState({
        from: filters.date?.from,
        to: filters.date?.to
      });
    
      useEffect(() => {
        setSelectedDay({ from: filters.date?.from, to: filters.date?.to });
      }, [filters]);
    
      return { selectedDay, setSelectedDay };
    };
    
    const useToggleDatePicker = () => {
      const [isDatePickerOpen, setIsDatePickerOpen] = useState(false);
    
      const toggleDatePicker = () => {
        setIsDatePickerOpen(!isDatePickerOpen);
      };
    
      return { isDatePickerOpen, toggleDatePicker };
    };
    ```
    

```jsx
export const isLoading = atom({
  key: 'isLoading',
  default: false
});
```
-> 과제를 채점하는 입장에서는 자세히 보기 보단 당황스러운 부분들을 보면 소거하는 방식으로 채점 ㅠㅠ

```tsx
export default function useGetTends() {
  const [isLoading, setIsLoading] = useState(false);
  const setTrendData = useSetRecoilState(trendState);

  useEffect(() => {
    const getTrendData = async () => {
      TREND_API.get().then((data) => {
        setTrendData(data.report.daily);
        setIsLoading(true);
      });
    };
    getTrendData();
  }, []);

  return { isLoading };
}
```

-   isLoading이 어째서 전역 상태…?

![[스크린샷 2022-11-08 오후 9.10.46.png| 300]]


-   ‘소리치는 아키텍처’, ==colocation==
-> 
-   정말 같은 depth에 있으면 좋을 컴포넌트들일까?
-> 카테고라이징을 잘하는 연습 

```tsx
export const dataConverter = {
  getRoas: (start, ended) => {
    return returnConvert(start, ended, 'roas');
  },
  getCost: (start, ended) => {
    return returnConvert(start, ended, 'cost');
  },
  getImp: (start, ended) => {
    return returnConvert(start, ended, 'imp');
  },
  getClick: (start, ended) => {
    return returnConvert(start, ended, 'click');
  },
  getConv: (start, ended) => {
    return returnConvert(start, ended, 'conv');
  },
  getConvValue: (start, ended) => {
    return returnConvert(start, ended, 'convValue');
  },
};
```

-   ==커링==을 사용하면 함수를 간결히 할 수 있다
    -> 함수를 리턴하는 함수를 커링이라고 한다. 
    -> 인자를 한번 더 쪼갠다 
    -> 관련 개념 [[클로저 다지기]]

    
-   서로 다른 역할을 하는 함수들은 서로 다른 함수로 만들어도 무방
    
-   suggestion
    
    ```tsx
    export const dataConverter = {
      getRoas: returnConvert('roas'),
      getCost: returnConvert('cost'),
      getImp: returnConvert('imp'),
      getClick: returnConvert('click'),
      getConv: returnConvert('conv'),
      getConvValue: returnConvert('convValue'),
    };
    ```
    
    ```tsx
    export const dataConverter = {
      getRoas: returnRoasConvert,
      getCost: returnCostConvert,
      getImp: returnImpConvert,
      getClick: returnClickConvert,
      getConv: returnConvConvert,
      getConvValue: returnConvValueConvert,
    };
    ```
    

```tsx
export const useGetChartValues = (option) => {
  const { startDate } = useStartDate();
  const { endedDate } = useEndedDate();

  const dailyData = trendDataSet.report.daily;
  let values = dailyData.filter((item) => {
    const itemDate = item.date;
    if (new Date(itemDate) >= new Date(startDate) && new Date(itemDate) <= new Date(endedDate)) {
      return item[option];
    }
  });

  values = values.map((item) => {
    return item[option];
  });

  let labels = dailyData.filter((item) => {
    const itemDate = item.date;
    if (new Date(itemDate) >= new Date(startDate) && new Date(itemDate) <= new Date(endedDate)) {
      return true;
    }
  });

  labels = labels.map((item) => {
    const itemDate = item.date;
    const month = new Date(itemDate).getMonth() + 1;
    const day = new Date(itemDate).getDate();
    return `${month}월 ${day}일`;
  });

  const color = CATEGORY_COLOR[option];

  return [labels, values, color];
};
```

-   ==불변성 → 예측 가능성==
    
-   suggestion
    
    ```tsx
    export const useGetChartValues = (option) => {
      const { startDate } = useStartDate();
      const { endedDate } = useEndedDate();
    
      const dailyData = trendDataSet.report.daily;
    
      const baseData = dailyData.filter((item) => {
        const itemDate = item.date;
        const isSelected = new Date(itemDate) >= new Date(startDate) && new Date(itemDate) <= new Date(endedDate);
        return isSelected;
      });
    
      const values = baseData.map((item) => ({ ...item, option }));
      const labels = baseData.map((item) => formatDate(item.date));
      const color = CATEGORY_COLOR[option];
    
      return [labels, values, color];
    };
    
    const formatDate = (date) => {
      const month = new Date(date).getMonth() + 1;
      const day = new Date(date).getDate();
      return `${month}월 ${day}일`;
    };
    ```
    
    ```tsx
    export interface AdService {
      getAds: (status?: AdsStatus) => Promise<Ad[]>;
    }
    
    export class LocalAdService implements AdService {
      private adRepository;
    
      constructor(adRepository: LocalAdRepository) {
        this.adRepository = adRepository;
      }
    
      getAds(status?: AdsStatus) {
        return this.adRepository.getAds(status);
      }
    }
    ```
    

```tsx
<Desc title={AD_ITEM_DESC[1]} desc={dateConverter(ad.startDate, ad.endDate)} />
```

-   인덱스는 숫자라서 의미를 담기 힘들다 = 읽기 힘들다
    
-   더 좋은 인터페이스를 고민해보자
    
-   suggestion
    
    ```tsx
    <StatusSection>
      <Card title="ROAS" data={roas} />
      <Card title="광고비" data={cost} />
      <Card title="노출 수" data={imp} />
      <Card title="클릭 수" data={click} />
      <Card title="전환 수" data={conv} />
      <Card title="매출" data={convValue} />
    </StatusSection>
    ```
    

```tsx
const handleOption1Click = (option: DropdownOption) => {
  trends?.setGraphOption(([opt1, opt2]) => (option.id === opt2.id ? [opt1, opt2] : [option, opt2]));
};

const handleOption2Click = (option: DropdownOption) => {
  trends?.setGraphOption(([opt1, opt2]) => (option.id === opt1.id ? [opt1, opt2] : [opt1, option]));
};
```

-   납득하기 어려운 변수명임. 기본 무시하지 말것.
-   순식간에 유지보수 하기 불가능에 가까운 앱이 됨. 단지 변수명을 제대로 쓰지 않았다는 이유만으로.

```tsx
useEffect(() => {
  const metaObj = {
    클릭수: 0,
    광고비: 0,
    전환수: 0,
    노출수: 0,
    매출: 0,
    ROAS: 0,
  };
  filteredData.forEach((data) => {
    metaObj.클릭수 += data.click;
    metaObj.광고비 += data.cost;
    metaObj.전환수 += data.conv;
    metaObj.노출수 += (data.click / data.ctr) * 100;
    metaObj.매출 += (data.roas * data.cost) / 100;
  });
  metaObj.ROAS = (metaObj.매출 / metaObj.광고비) * 100;
  setMetaData({ ...metaObj });
}, [filteredData]);
```

-   적절한 메서드를 쓰자
    
-   suggestion
    
    ```tsx
    useEffect(() => {
      const initialData = {
        클릭수: 0,
        광고비: 0,
        전환수: 0,
        노출수: 0,
        매출: 0,
        ROAS: 0,
      };
      const result = filteredData.reduce(
        (acc, cur) => ({
          클릭수: acc.클릭수 + cur.클릭수,
          광고비: acc.광고비 + cur.광고비,
          전환수: acc.전환수 + cur.전환수,
          노출수: acc.노출수 + cur.노출수,
          매출: acc.매출 + cur.매출,
        }),
        initialData
      );
    
      setMetaData({ ...result, ROAS: (result.매출 / result.광고비) * 100 });
    }, [filteredData]);
    ```
    

```tsx
const periodSlice = createSlice({
  name: "period",
  initialState: initialPeriodState,
  reducers: {
    changePeriod(state, action) {
      state.startDate = action.payload.startDate;
      state.endDate = action.payload.endDate;
    },
  },
});
```

-   기간을 반드시 redux로 관리해야 할까?

```tsx
const { isLoading, data: trendData } = useQuery(  
  ['trend'],  
  () => adService?.getTrend(),  
  {  
    staleTime: 1000 * 60 * 60,  
    cacheTime: 1000 * 60 * 60,  
  }  
);  const { data: listData } = useQuery(  
  ['adList'],  
  () => adService?.getAdList(),  
  {  
    staleTime: 1000 * 60 * 60,  
    cacheTime: 1000 * 60 * 60,  
  }  
);

useEffect(() => {  
  trendDispatch({  
    type: DataActionEnum.SET_DATA,  
    data: trendData?.report.daily || [],  
  });  
  trendDispatch({ type: DataActionEnum.SET_IS_LOADING, isLoading });  
}, [trendData, isLoading]);  useEffect(() => {  
  listDispatch({  
    type: DataActionEnum.SET_DATA,  
    data: listData?.ads || [],  
  });  
}, [listData]);
```

-   불필요한 context api

```tsx
const {
  isEdit,
  editAdItem,
  handleEdit,
  handleCancel,
  handleSubmit,
  renderAdItemSpan,
  renderAdBudgetSpan,
  renderAdItemSpanDepth2,
  renderAdItemCheck,
  renderDatePicker
} = useAdItemEdit(adItem);
```

-   이건 뷰와 로직이 분리된 것일까 아닐까?