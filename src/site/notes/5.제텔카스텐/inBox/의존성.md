## 의존성 역전 원칙(DIP)

의존성이란 특정한 모듈이 동작하기 위해서 다른 모듈을 필요로 하는 것을 의미합니다.

의존성 역전 원칙은 “유연성이 극대화된 시스템"을 만들기 위한 원칙입니다. 이 말은 곧 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 것을 의미합니다.

여기서 **추상**과 **구체**라는 말이 나오게 됩니다.

==추상==이란 구체적인 구현 방법이 포함되어 있지 않은 형태를 의미합니다. 추상이란 말이 어려울 수 있지만, **결국 그 내부가 어떻게 구현되어있는지 신경쓰지 않고 그냥 내가 “해줘야 하는 일”과 “결과"만 신경쓸 수 있게 된다는 말**입니다.

==구체==는 반대로 실질적으로 해당 동작을 하기 위해서 수행해야 하는 구체적인 **일련의 동작과 흐름**을 의미합니다. 이런 구체적인 동작들을 굉장히 빈번하게 변경될 여지가 많습니다. 따라서 이러한 구체에 애플리케이션이 점점 의존하게 된다면 결국 구체가 변할 때 마다, 내 애플리케이션도 그에 맞춰서 변화해야 한다는 의미가됩니다.

실생활의 예를 통해 추상과 구체의 개념을 알아봅시다. 우리 모두는 스마트폰을 활용합니다. 그리고 스마트폰은 전화를 할 수 있습니다. 우리는 스마트폰의 전화 앱을 실행하고

1.  번호를 입력한다.
2.  통화 버튼을 누른다.

의 과정을 거치면 통화가 이루어진다는 것을 알고 있습니다.

하지만 저 내부적인 과정에서는 우리의 요청을 통신사가 받아서, 기지국을 찾고, 상대방의 전화번호와 연결된 기지국을 찾고 두개의 음성을 연결해서 실시간으로 전달해주는 구체적인 과정이 발생합니다.

우리가 어떤 스마트폰을 사용하든, 그리고 어떤 통신사를 사용하든 번호를 입력하고, 통화버튼을 누른다는 추상은 변하지 않습니다. 하지만 통신사가 변경되면 통신사별로 통화를 연결할 때 사용하는 프로세스, 기지국등은 미묘하게 달라질 것입니다. 만약 우리가 통신사를 변경할 때 마다 이러한 모든 프로세스를 일일이 맞춰서 변경해야지만 통화기능이 동작하게 되어있다면 대부분의 사용자들은 결국 통신사를 변경하는 것을 포기하게 될 것입니다.

이처럼 변화가 자주 발생하는 추상에 의존하는 것은 애플리케이션 구조 상 기피해야 할 항목입니다.

하지만, 우리가 일반적으로 코드를 작성하다보면 위와 같이 구체에 의존하는 경우가 자주 발생하게 됩니다.

```jsx
fetch("todos", {
	headers:{
		Authorization:localStorage.getItem("ACCESS_TOKEN");
	}
}
```

위 코드는 두가지 문제가 있습니다.

==내 코드의 문제점!!!!==
1.  localStorage라는 구체적인 사항에 의존하고 있습니다. 이는 storage를 추후에 다른 저장소로 변경하기 힘들다는 것을 의미합니다.
2.  localStorage는 “브라우저”에서 제공하는 API입니다. 브라우저는 우리가 개발한 애플리케이션이 아닌 ==외부 요소==입니다. 이런 애플리케이션 외부의 요소들은 변화가 발생할 수 있으며, 가장 큰 문제는 어떤식으로 변화할 지 우리가 컨트롤 할 수 없다는 점입니다. 따라서 이런 요소들에 직접적으로 의존하는 것은 좋지 않습니다.

물론, 구체적인 요소에 하나도 의존을 하지 않고 애플리케이션을 만들 순 없습니다. 실질적으로 브라우저에서 제공하는 기능을 이용해야 한다는 사실을 무시할 순 없으니까요

하지만, 이 외부 요소에 직접적으로 의존하는 코드를 최소화하고, 전체적인 제어권을 우리의 애플리케이션 안으로 가져올 순 있습니다.

먼저, localStorage를 이용해서 최종적으로 어떤 기능이 필요한지 **“추상적”**으로 정의해봅시다.

1.  일단, Storage를 이용하는 이유는 Token을 관리하기 위해서입니다. 그렇다면 Token을 관리하기 위해서는 어떤 기능이 필요한지 생각해봅시다.
2.  Token을 관리하기 위해서 일반적으로 진행하는 작업은 크게 아래 3가지입니다.
    1.  **저장**
    2.  **삭제**
    3.  **저장된 토큰을 가져오기**

위 과정을 통해서 토큰을 이용해서 수행할 작업들이 정리되었습니다. 이제 이것을 코드형태로 정의해보겠습니다.

자바스크립트에는 추상적인 요소들을 정의할 수 있는 방법이 없기에 주석을 이용해서 표현하겠습니다.

```tsx
/*
	TokenRepositoryInterface

	  save(token:string):void
	  get():string
	  delete():void
*/
```

여기서 Interface란 용어를 사용했습니다. Interface란 두가지 다른 요소들이 소통하는 지점을 의미합니다.

즉, 일종의 가이드라인이라고 볼 수 있습니다. 앞으로 Token을 사용할때는 “save, get, delete라는 세가지 메서드를 통해서 소통하자”라고 정해두는 것입니다.

이 Inteface의 가장 큰 특징은 추상적이라는 것입니다. save, get, delete라는 3가지 메서드가 있어야한다는 것과 각각 어떤 input과 output을 가져야하는지는 정의해두지만 그 외에 구체적인 구현사항들은 하나도 명시되어있지 않습니다.

즉, 이 Inteface를 사용하는 입장에선 Inteface에서 정한 약속이 잘 지켜지기만 한다면 “내가 해줘야 하는 일”과 “결과”만 신경쓰면되고 세부 사항은 신경쓰지 않아도 된다는 것입니다.

그리고 Interface를 실제로 구체적으로 구현해야하는 입장에서는 Interface에서 정한 약속이 잘 지켜지기만 한다면 내가 세부적인 구현방법을 어떻게 바꾸든지 아무런 상관이 없습니다. 최종적으로 저 Interface에서 약속된 동작을 지켜주기만하면 됩니다.

Interface의 개념은 우리가 일반적으로 백엔드와 소통하는 API를 떠올려보면 이해하기 쉽습니다.

API는 Application Programming Interface입니다. 즉 각기 다른 Application끼리 소통하기 위한 추상적인 Interface를 정리해둔 것을 의미합니다. 생각해보면 백엔드와의 통신은 Interface를 통해서만 진행됩니다.

우리는 API를 사용할 때 `/todo` 엔드포인트로 호출을 하면 todolist가 응답으로 온다는 추상적인 동작만 가지고 백엔드와 통신을 시도합니다. 세부적으로 백엔드가 어떤 DB를 사용하고 어떤 언어를 사용하고 어떤 프레임워크를 사용해서 저 기능을 구현했는지는 우리의 관심사가 아닙니다. 단지 우리가 신경쓰는 것은 “`/todo` 로 요청하면 todolist가 응답으로 온다”라는 동작 자체에만 관심을 가지고 있습니다.

백엔드 입장에서도 API에서 정해둔 약속만 지킨다면 구체적인 사항인 프레임워크등은 얼마든지 변경할 수 있습니다. 예를 들어 내가 Node로 구현을 했든, Python으로 구현을 했든, Java로 구현을 했든 결과적으로 `/todo`에 요청이 들어오면 todolist만 응답을 해주면 되는 것입니다.

이러한 의미에서 우리는 Interface란 용어를 자주 사용합니다. 가장 자주 사용하는 상황인 프론트-백엔드와의 소통 외에도 리액트같은 라이브러리에서 제공해주는 여러 기능들도 API로 부릅니다. 그 이유는 리액트과 같은 아리브러리는 우리가 개발하는 애플리케이션과 별개의 다른 프로그램이고 그 프로그램 안에서 어떻게 세부 동작이 이루어지는지는 몰라도 그 프로그램에서 제공해주는 여러 함수들을 통해서 해당 라이브러리를 사용하기 때문입니다.

이제 저 TokenRepositoryInterface에 맞춰서 실제 우리가 원하는 기능들을 구체적으로 구현해보겠습니다.

```jsx
/*
	TokenRepositoryInterface

	  save(token:string):void
	  get():string
	  delete():void
*/

class LocalTokenRepository {
  #TOKEN_KEY = "ACCESS_TOKEN";

  save(token) {
    localStorage.setItem(this.#TOKEN_KEY, token);
  }

  get() {
    return localStorage.getItem(this.#TOKEN_KEY);
  }

  remove() {
    localStorage.removeItem(this.#TOKEN_KEY);
  }
}

const tokenRepository = new LocalTokenRepository();

fetch("todos", {
	headers:{
		Authorization:tokenRepository.get();
	}
}
```

위와 같은 방식으로 코드를 변경하게 되면 외부 요소인 localStorage는 TokenRepository Class에 의해서 관리되게 됩니다. TokenRepository Class는 우리 애플리케이션 내부의 요소기에 우리가 통제할 수 있게 됩니다. 그리고 TokenRepository Class는 TokenRepository Interface에서 정의된 사항들을 모두 구현해줘야 할 책임이 있습니다. 이==말은 곧 TokenRepository Class가 TokenRepository Interface에 의존한다고 볼 수 있습니다.==

이제 애플리케이션 내에서의 의존관계는 변경되게 됩니다. 외부 요소인 localStorage에 대한 의존성을 최대한 줄어들었으며 구체적인 요소인 TokenRepository Class는 추상적인 요소인 TokenRepository Interface에 의존하게 되었습니다.

만약 이 상황에서 외부 요소들이 변경되게 된다면 어떻게 될까요? 외부요소들이 변경되게 된다면 외부 요소들의 동작을 tokenRepositoryInterface에 맞춰서 다시 구현해주면 됩니다. sessionStorage로 변경되든, cookie로 변경되든 외부요소들이 어떻게 되든 상관없이 외부요소들은 무조건 save, get, remove라는 tokenRepositryInterface에 구현된 3가지 동작을 할 수 있어야 합니다.

```jsx
class SessionTokenRepository {
  #TOKEN_KEY = "ACCESS_TOKEN";

  save(token) {
    sessionStorage.setItem(this.#TOKEN_KEY, token);
  }

  get() {
    return sessionStorage.getItem(this.#TOKEN_KEY);
  }

  remove() {
    sessionStorage.removeItem(this.#TOKEN_KEY);
  }
}
```

**의존성 역전 원칙 설명해주심**
이 상황에서 코드의 실행 흐름과 의존성의 방향을 생각해봅시다.

코드는 아래의 방향대로 실행됩니다.

1.  API 호출 코드 → tokenRepositry → localStorage

기존의 구체적인 localStorage를 그대로 사용하고 있던 코드의 의존성 방향은 아래와 같습니다.

1.  API 호출 코드 → localStorage

위와 같은 의존성이 설정되어있기에 localStorage가 변경되면 API 호출 코드 또한 변경되어야 합니다.

하지만 tokenRepositoryInterface를 이용해서 추상적인 요소로 의존성의 방향을 변경해버린 코드는 아래와 같은 호출 흐름과 의존성 방향을 가집니다.

-   호출흐름: API 호출 코드 → tokenRepository Interface → tokenRepositry Class → localStorage
-   의존성방향: API 호출 코드 → tokenRepository Interface ← tokenRepositry Class → localStorage

**-> 클래스가 interface에 의존하고 있다!!** 
-> 클래스가 제어권을 가지게 된다. 


이처럼 특정 시점에서 코드의 실행 흐름(제어 흐름)과 의존성이 방향이 반대로 뒤집혔기에 이를 **“의존성 역전 원칙(DIP)”**이라고 부르며 **IoC(Inversion of Control)**이라고도 표현합니다.

DIP원칙을 적용하면 애플리케이션이 상대적으로 변경 여지가 적인 추상적인 요소에 의존하도록 설계할 수 있으며, 변경될 여지가 많은 구체적인 요소에 직접적으로 의존하지 않을 수 있게 됩니다. 이 말은 곧 소프트웨어에 필연적인 다양한 변경에 대해서 손쉽게 대응할 수 있다는 의미입니다.

## 의존성 주입

의존성 주입이란 특정한 모듈에 필요한 의존성을 내부에서 가지고 있는 것이 아니라 ==해당 모듈을 사용하는 입장에서 주입해주는 형태로 설계하는 것을 의미합니다.==

-   의존성 주입 X
    
    ```jsx
    import httpClient from "./httpClient";
    import tokenRepository from "./tokenRepository";
    
    class AuthService {
      signup(email, password) {
        httpClient
          .fetch("auth/signup", {
            method: "POST",
            body: JSON.stringify({
              email,
              password,
            }),
          })
          .then((res) => res.json())
          .then(({ access_token }) => tokenRepository.save(access_token));
      }
    
      singin(email, password) {
        httpClient
          .fetch("auth/signup", {
            method: "POST",
            body: JSON.stringify({
              email,
              password,
            }),
          })
          .then((res) => res.json())
          .then(({ access_token }) => tokenRepository.save(access_token));
      }
    
      logout() {
        tokenRepository.remove();
      }
    }
    
    const authService = new AuthService();
    ```
    
-   의존성 주입 O
    
    ```jsx
    import httpClient from "./httpClient";
    import tokenRepository from "./tokenRepository";
    
    class AuthService {
      constructor(httpClient, tokenRepository) {
        this.httpClient = httpClient;
        this.tokenRepository = tokenRepository;
      }
    
      signup(email, password) {
        this.httpClient
          .fetch("auth/signup", {
            method: "POST",
            body: JSON.stringify({
              email,
              password,
            }),
          })
          .then((res) => res.json())
          .then(({ access_token }) => this.tokenRepository.save(access_token));
      }
    
      singin(email, password) {
        this.httpClient
          .fetch("auth/signup", {
            method: "POST",
            body: JSON.stringify({
              email,
              password,
            }),
          })
          .then((res) => res.json())
          .then(({ access_token }) => this.tokenRepository.save(access_token));
      }
    
      logout() {
        this.tokenRepository.remove();
      }
    }
    
    const tokenRepository = new TokenRepositry();
    const httpClient = new HttpClient(process.env.BASE_URL);
    const authService = new AuthService(httpClient, tokenRepository)
    ```
    

의존성 주입을 적용하면 **좋은 점은 해당 모듈에서 직접적으로 의존성을 가지고 있지 않게 되는 것입니다.** 예를들어 의존성 주입을 하지 않은 경우에는 AuthService 클래스에서 직접적으로 httpClient, tokenRepositry를 의존하고 있기에 관련된 동작을 변경하려면 AuthService를 직접 수정해야 합니다.

하지만 의존성 주입을 이용해서 클래스 내부에서 가지고 있는 것이 아니라, 클래스를 생성할 때 외부에서 주입하는 식으로 변경하게 되면 추후에 AuthService의 코드 수정 없이 AuthService에서 사용하는 httpClient, tokenRepositry와 연관된 동작을 쉽게 변경해서 다양하게 사용할 수 있게 됩니다.

==이는 곧 프로그램의 유연성, 테스트의 용이성, mocking등==을 쉽게 활용할 수 있게 된다는 의미입니다.

==보통 Class 단위에서 많이 사용되는 용어이기에 어려움을 느낄 수 있는데 익숙한 함수로 생각하면 됩니다==. 함수의 경우에는 ==인자==를 통해서 내부에서 사용할 요소를 전달받을 수 있는데, 동작을 내부에서 전체 다 가지고 있는 것이 아니라, 외부에서 받을 수 있게 설정하면 훨씬 더 유용하게 사용할 수 있게 되는 것을 생각해보면 됩니다.

```jsx
const log = (data) => console.log(data);
log("Hello, World");

// --------------------------

const log = (logger, data) => logger(data);

log(console.log, "Hello, World");
log(console.info, "Hello, World");
log(console.warn, "Hello, World");
log(console.error, "Hello, World");
log(customLogger, "Hello, World");
```

기본적으로 Class의 경우에는 constructor를 통해서, 함수의 경우에는 인자를 통해서 의존성을 주입하게 됩니다.

그런데 리액트 애플리케이션을 설계하다보면 컴포넌트에도 의존성을 주입하고 싶은 욕구가 생깁니다. 하지만 리액트는 props를 통해서 단방향으로만 데이터를 전달할 수 있기에 의존성을 주입하기가 쉽지 않습니다. 이를 해결하기 위해서 **[[Context API]]를 컴포넌트에게 의존성을 주입하는 용도**로 사용할 수 있습니다.


- 코드 보는 순서 
-> readme -> package.json -> router 

라이브 코딩 (황연욱)
- 흐름
1. (interface)기능을 미리 정의한다. 
코드 짜기 전에 interface (input, output) 을 미리 생각해야한다.
2. 만들다보니 횡단 관심사 분리해주자
3. httpCLient 만드심
	```
	
	```
4. 그리고 tokenrepository Class 를 만드심. 
5. 본론으로 돌아와서 AuthService에 의존성 주입시켜줌.

6. todoService를 만든다. 
	클래스 안에서 httpClient 를 의존성 주입하고 get , create 매소드를 만든다. 
7. 다 만든애들을 컴포넌트에 넘겨줘야한다 
8. context API를 써보자 
9. 

[[this-binding]]

![[스크린샷 2022-11-05 오후 12.59.30.png]]
singup = authService.signup을 하면 여기서 This는 window!! 그래서 .bind로 this를 바인딩해줘야한다.!! 이게 [[실행 컨텍스트]]와 연관 


--> 의존성 주입을 정확히 알아야 재밌는 코딩이 가능 


자바스크립트는 OOP와 funtion의 이점을 살려서 이용하면된다. 