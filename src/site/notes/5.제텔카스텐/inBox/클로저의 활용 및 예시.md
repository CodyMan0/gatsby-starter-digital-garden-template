---
aliases: []
tags : 
---
Up : [[HOME 🌎]]

출처 :
저자 :
URL : 
인용 : 

1. **상태**를 안전하게 변경하고 유지하는데 활용된다. (은닉화)
2. [[함수형 프로그래밍]]의 부수효과를 최대한 억제 -> 안정성 높이기 위해 활용 **???** 
3. react hooks 의 useState을 활용하여 closure 생각해보기 


# 생활 코딩 클로저편 (주제 : 정적 스코프 관련)

```js
<html>
<body>
<script>
    let l0 = 'l0';
    function foo(){
        let l1 = 'l2'
        console.log(l0,l1);
    }
foo();
</script>
</body>
</html>
```

![[스크린샷 2022-11-21 오후 1.59.16.png]]

1. Call Stack에 있는 foo 함수의 유효범위 안에 있는 변수를 찾는다.
2. 로컬에 l1은 찾았고 l0을 찾기 위해 다음 스코프인 script 스코프에서 찾는다.
```js
let l0 = 'l0';
    function foo2(){
        let l2 = 'l2'
        console.log(l0,l1,l2);
    }
    function foo(){
        let l1 = 'l1'
        console.log(l0,l1);
        foo2();
    }
foo();
```
Q. l1이 정의되지 않는다!? 
foo2의 실행 컨텍스트 -> 로컬에 l2 , script에서 l0을 찾았다. 
foo의 실행 컨텍스트 -> 로컬에 l1 , script에서 l0을 찾았다. 

여기서 알 수 있는 것은 ? 실행된 위치에 따라서 스코프 체인이 적용되는 것이 아닌 정의된 위치에서 적용된다를 이제 이해함. 

호출된 위치에 따라 스코프가 달라지는 것을 -> [[dynamic scope]]
하지만 [[자바스크립트]]는 정적 스코프(렉시컬 스코프{어휘적 스코프 })이다. 

```js
let l0 = 'l0';
    
    function foo(){
        let l1 = 'l1'
        console.log(l0,l1);
        function foo2(){
	        let l2 = 'l2'
	        console.log(l0,l1,l2);
    }
        foo2();
    }
foo();
```


![[스크린샷 2022-11-21 오후 2.15.06.png]]






# 1. 은닉화
## 예시 1 전역에 선언된 변수 

![[스크린샷 2022-11-22 오후 12.15.16.png]]
문제 상황  : 값을 예측 가능하게 변경하고 싶은데.. 전역에 변수를 선언하고 함수 내에서 참조하여 값을 변경할때 문제는 값이 오염되는 문제 

## 클로저로 해결 
그래서 이 문제를 해결하기 위해 클로저를 사용하여 값이 오염되지 않도록 하기 위해 사용한다. 
![[스크린샷 2022-11-22 오후 12.19.43.png]]


전역에 있는 변수를 함수내에 선언하고 콜백함수를 리턴하는 방식으로 closure 함수를 구현하여 getAdd()안에 있는 변수를 은닉화시켜준다. 


## 잠시 딴 길 IIFE 모듈 패턴? 
![[스크린샷 2022-11-22 오후 12.23.03.png]]
IIFE (immediately invoke function expression) 방식을 더 선호한다. 
자바스크립트는 모듈화가 안된다? 지금은 할 필요가 없다! 왜 ? 모듈화가 되어있어서 

# 2. useState clone coding 
https://codesandbox.io/s/eager-snow-ueipf2?file=/src/index.js

### 생각의 연결고리
분야 :

키워드 :

관련있는 메모 : [[useState]]
