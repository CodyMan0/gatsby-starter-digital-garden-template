---
aliases: []
tags : 
---
Up : [[HOME 🌎]]

출처 :
저자 :
URL : 
1. https://so-so.dev/react/make-select/
2. https://www.youtube.com/watch?v=pcMYcjtWwVI
3. https://circus7.tistory.com/6
인용 : 



### 생각의 연결고리
분야 :

키워드 :

관련있는 메모 :


-   타입스크립트 👍
    
-   CRA 말고 Vite도 찾아보면 좋음 → 더 가볍고 빠름
    
-   자잘한 버그들이 굉장히 많음
    -   어쩔 수 없음 원래 완벽하게 만들기 힘듬

-   디바운싱 & 쓰로틀링 (with 클로저)
    -   디바운싱 : 마지막 호출이 이뤄진 후 → 설정한 인터벌이 지나고 실행 (바운싱 : 스위치의 접점에서 진동이 일어나면서 여러번 접지하는 현상)



        ```tsx
        const debounce = <Params extends any[]>(
          func: (...args: Params) => any,
          timeout: number
        ): ((...args: Params) => void) => {
          let timer: NodeJS.Timeout;
        
          return (...args: Params) => {
            clearTimeout(timer);
        
            timer = setTimeout(() => {
              func(...args);
            }, timeout);
          };
        };
        ```
        
        ```tsx
        import { useState, useEffect } from "react";
        
        const useDebounce = (value: string, delay = 600) => {
          const [debounceValue, setDebounceValue] = useState(value);
        
          useEffect(() => {
            const timer = setTimeout(() => {
              setDebounceValue(value);
            }, delay);
        
            return () => {
              clearTimeout(timer);
            };
          }, [value, delay]);
        
          return { debounceValue };
        };
        
        export default useDebounce;
        ```
        
    -   쓰로틀링 : 시간을 chunk로 나누어 → 이벤트가 연속적으로 발생하더라도 chunk에 한번씩만 실행하기 (목이 졸려 캑캑 대는 사람 생각하기…)
        
        ```tsx
        export const throttle = <Params extends any[]>(
          func: (...args: Params) => any,
          timeout: number
        ): ((...args: Params) => void) => {
          let timer: NodeJS.Timeout | null = null;
        
          return (...args: Params) => {
            if (timer) return;
        
            timer = setTimeout(() => {
              func(...args);
              timer = null;
            }, timeout);
          };
        };
        ```
        
-   캐시(Cache)
    
    [캐시 (Cache) (w/ Next.js)](https://www.notion.so/Cache-w-Next-js-3f556192758f42e1a7215a21ae19e43b)
    
    -   있으면 바로 쓰고, 없으면 채워뒀다 나중에 쓰고
    -   만료(Expire) → 캐시의 가장 핵심 문제 (잘못된 값을 돌려줄 수 있기 때문에)



# 클로저 중요!! 
원래 함수는 한번 실행하고 메모리에 아무것도 남기지 않는데 디바인싱은 함수를 리턴한다 근데 험수를 리턴한다는 것은 어딘가를 값으로 가지고 있따는 것. 실해하려고 보니 타이머가 있다 상위 스코프에 있는 debounce 함수의 본문에 있다.
timer 신입사원 ㅋㅋㅋ 부장님이 퇴근하지 못해서 퇴근을 못함. 언제든지 부를 수 있기에 

정리 : 언제든지 이안에 변수가 참조될 수 있기에 메모리에서 지우지 못한다. 

이 개념 파생이 -> useState!!!! 
클로저와 useState와 완전 연관!! 

# 캐시는 만료가 중요
왜? \


# 꿀팁

const foo = () => {
	console.time();
	console.timeEnd(0);
}

test : 0.,002020100214ms


왜 S3에는 API를 같이 베포하지 못하는걸까? 
-> 서버를 띄우면 npm start로 해야하는 측면에서 생각해보면 

# 공부해야하는 것
 closure
 event bubbling 
 suspense -> 비동기적으로 렌더링? 
 props drilling이 왜 문제? -> state, props를 전달하는 것 뿐아니라 전달된 애들에게 렌더링이 일어난다는 것이 문제. 
 
 
 





# 잘한 팀 
캐싱 잘한팀 10팀 12팀
서스팬드 : 9팀 

